{"componentChunkName":"component---src-templates-blog-post-js","path":"/flask","result":{"data":{"markdownRemark":{"rawMarkdownBody":"\n# An Intro to Web Dev\n\n> Featuring the Web Framework Flask!\n\nAs a programmer, it can seem like building websites involves [countless](https://xkcd.com/927/) frameworks and [complex](https://xkcd.com/1270/) paradigms… However, the [complexity](https://www.cis.upenn.edu/~cis455/) of web development has actually led to the creation of easy-to-use libraries and frameworks that abstract most of the complicated processes!\n\nIn this lecture, we will be working with [Flask](https://github.com/pallets/flask), a Python framework for web development, by using it to build a [REST API](https://developer.mozilla.org/en-US/docs/Glossary/REST). Web development involves a lot of moving parts - we recommend you ask many questions!\n\n## HTTP and REST APIs\n\n**HTTP** (Hyper Text Transfer Protocol) is a way for us to communicate between machines. The core technology was developed by Tim Berners-Lee in 1989 at CERN. Put simply, this is the underlying technology that has enabled the internet to work.\n\nHTTP is a protocol that consists solely of requests and responses. HTTP is stateless; this means that requests/responses are made independent of each other. Typically a client (e.g. website and mobile app) will make requests for resources (e.g. text/images) from a server. It’s is a common mistake to conflate **HTML** (Hyper Text Markup Language) with HTTP. The distinction is that HTML is the content of a webpage that will eventually be displayed to a user, where HTTP is the transportation method of the HTML.\n\nThe client and server can exist as one application or separately (as is typically the case with Flask). The actual layers of the protocol can get very technical, but this is essentially all you need to understand as a Python developer. As Python developers, we build **REST APIs**, server applications that respond to requests accessed through urls (e.g. http://upenn.edu) over HTTP. Data in REST API’s are typically sent and received using **JSON** (Javascript Object Notation), which follows a key-value interface similar to dictionaries.\n\nIf you are interested in learning more about the infastructure of the web, we recommend checking out [NETS-150](https://www.cis.upenn.edu/~mkse150/), [NETS-212](https://www.cis.upenn.edu/~nets212/), or if you are feeling really adventurous, [CIS-455](https://www.cis.upenn.edu/~cis455/)!\n\n## Introducing: Flask\n\nAs mentioned above, we will be building a REST API in Python using a library named [Flask](https://github.com/pallets/flask). Flask is a web framework that allows us to build a server that other applications can make HTTP requests to. Flask is the backbone for the architecture of a lot of Python software, including [LinkedIn](https://engineering.linkedin.com/blog/) and [Pinterest](https://medium.com/pinterest-engineering/) (but is 100% open source).\n\n## Creating a Flask application\n\nFlask makes it quick and simple to build a server using Python. First, we need to install Flask using `pip` and create the server file. In this demo, we will be building a REST API to clone a question/answering site like Stack Overflow.\n\n1. Create a folder using `mkdir 192overflow`.\n2. Enter the folder using `cd 192overflow`.\n3. Create a file named `server.py` here with a text editor or `touch`.\n4. Install Flask using `pip install flask`.\n5. Place the following contents in the `server.py` file and save.\n\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n\treturn \"Hello World!\"\n\nif __name__ == \"__main__\":\n\tapp.run(port=5000, debug=True)\n```\n\n6. Run the server using `python server.py`.\n7. Access the server at `localhost:5000` in your web browser.\n\n## Defining Routes\n\nIn the above example, we build a server that exposes a REST API. Our only access point to the interface is the route `\"/”` that returns the return value of a function named `hello()`. We defined this behavior using the function decorator `@app.route(\"/\")`.\n\nWe can similarity create decorated functions that allow us to define more routes. Let’s change the message of our function to return `\"Welcome to 192overflow's API!\"`. The Flask server automatically reloads and if we refresh our web browser, we should see the updated value.\n\n## Making Requests to Query\n\nWe define a dictionary mapping questions to answers before we define routes:\n\n```python\nanswers = dict()\n# This also works!\nanswers = {}\n```\n\nWe can now create another route to take in an argument (a string value of the question) and return a result in JSON. We import the `jsonify` and `request` module from Flask using `from flask import jsonify, request`. We can now add another route that takes in a string of the question (using only alphanumeric characters with underscores for spaces):\n\n```python\n@app.route(\"/api/answers\", methods=['GET'])\ndef get_answer():\n\tquestion = request.args.get('question')\n\tif question in answers:\n\t\treturn jsonify({\"status\": 200, \"answer\": answers[question]})\n\telse:\n\t\treturn jsonify({\"status\": 404, \"message\": \"No answer.\"})\n```\n\nNow, we can access this route from our browser supplying a URL argument for the question `localhost:5000/api/answers?question=what_is_love`. Clearly, we don’t have any questions or answers, we can change that by adding another route for adding a question and answer pairing.\n\n## Making Requests to Insert\n\nNext, we define a route for setting the answer to a question. Both arguments are sent using a JSON encoded object, that we decode using the `get_json` function to convert the arguments to a dictionary.\n\n```python\n@app.route(\"/api/answers\", methods=['POST'])\ndef post_answer():\n\tdata = request.get_json()\n\tquestion = str(data[\"question\"])\n\tanswer = str(data[\"answer\"])\n\tanswers[question] = answer\n\treturn jsonify({\"question\": question, \"answer\": answer})\n```\n\nWe can test this in the command line using:\n\n```bash\ncurl --header \"Content-Type: application/json\" \\\n  --request POST \\\n  --data '{\"question\":\"what_is_love\", \"answer\":\"dont_hurt_me\"}' \\\n  http://localhost:5000/api/answers\n```\n\nIf you're not on a UNIX based system (looking at you, Windows) then you can download [curl](https://curl.haxx.se/) here. Instead of the above command, navigate to the directory you unzipped the curl executable in, and run\n```bash\ncurl.exe --header \"Content-Type: application/json\" \\\n  --request POST \\\n  --data '{\"question\":\"what_is_love\", \"answer\":\"dont_hurt_me\"}' \\\n  http://localhost:5000/api/answers\n```\ninstead. (Same thing, except we're telling Windows to use the curl executable we downloaded.)\n\nOr install a graphical HTTP client like [Postman](https://www.postman.com/), and click the 'Send' button after filling out the fields like below:\n![screenshot](https://i.imgur.com/PedEksL.png)\n\n## Exporting to JSON\n\nHowever, you may have noticed that the server will wipe all the data whenever we navigate away from it. This is because our server is still a Python script and variables are often reset. We need some more persistent server-side storage, similar to how a site can remember your searches.\n\nWe can use the `json` library (bundled with Python, different from `jsonify`) to save information into a `.json` file that can be serialized and deserialized as we wish. We can import the `json` library with a simple `import json`. We use the `with` keyword to safely interact with file I/O (e.g. reading and writing without worrying about closing).\n\n```python\n@app.route(\"/api/answers\", methods=['POST'])\ndef post_answer():\n\tdata = request.get_json()\n\tquestion = str(data[\"question\"])\n\tanswer = str(data[\"answer\"])\n\twith open('db.json', 'r') as db_read:\n\t\tdata = json.load(db_read)\n\twith open('db.json', 'w') as db_write:\n\t\tdata[question] = answer\n\t\tjson.dump(data, db_write)\n\treturn jsonify({\"question\": question, \"answer\": answer})\n```\n\nWe’ll also need to update how we query the database so that we query the JSON database as opposed to our `answers` dictionary.\n\n```python\n@app.route(\"/api/answers\", methods=['GET'])\ndef get_answer():\n\tquestion = request.args.get('question')\n\twith open('db.json', 'r') as db_read:\n\t\tanswers = json.load(db_read)\n\tif question in answers:\n\t\treturn jsonify({\"answer\": answers[question]})\n\telse:\n\t\treturn jsonify({\"message\": \"No answer.\"})\n```\n\n**DISCLAIMER**\nSaving to a local file (like our `db.json`) can create consistency issues if multiple users edit/query the same file at the same time. We’ll ignore this scenario for this course since it isn’t a Python-specific issue. There are [entire courses](https://www.seas.upenn.edu/~cis550/) devoted to solving this and the other challenges that arise when storing data, if you're interested.\n\n## Rendering HTML\n\nAllowing others (i.e. non-technical people) to use your project will involve the use of some HTML. However, `.html` files are static, and thus aren’t good by themselves at receiving input and processing/result results. Using Flask, we can solve this by defining **templates** that we can “inject” Python data into. Let’s add another route to display a template at `GET /answers` (NOTE: not `GET /api/answers`):\n\n```python\n@app.route(\"/answers\", methods=['GET'])\ndef render_answer():\n\tquestion = request.args.get('question')\n\twith open('db.json', 'r') as db_read:\n\t\tanswers = json.load(db_read)\n\tif question in answers:\n\t\t# Make sure to also import render_template from flask in the imports above!\n\t\treturn render_template(\"answer.html\", question=question, answer=answers[question])\n\telse:\n\t\treturn jsonify({\"status\": 404, \"message\": \"No answer.\"})\n```\n\nHere, we perform the same logic as before in `/api/answers`. However, instead of returning a JSON response upon success, we return a rendered template. We pass in keyword arguments (i.e. `kwargs`) for the question and answer to be rendered in the HTML.\n\nNow, we need to define the HTML page. Let’s create a new folder named `templates` in the `192overflow` directory that contains a single file named `answer.html`. In this file, we’ll adding some HTML code:\n\n```html\n<h1>Question</h1>\n<p>{{question}}</p>\n<h2>Answer</h2>\n<p>{{answer}}</p>\n```\n\nEssentially, we are defining a webpage that has large, title text that will indicate whether the following text is a question or answer, followed by the question/answer. The double curly braces `{{variable}}` signify that some keyword argument `variable` will be passed in as a Python object to be rendered.\n\n## Conclusion\n\nIn this section of the course, you learned some crucial paradigms for web development and software engineering as a whole:\n\n1. HTTP\n2. JSON\n3. REST APIs\n4. Flask\n5. HTML rendering\n\nSome next steps would involve adding more routes, some way to add users, and more front-end (HTML) pages! Feel free to email the staff if you have any questions!\n\nLater assignments will be in [Django](https://www.djangoproject.com/), another Python framework which comes with more built in functionality at the cost of being more abstract/harder to understand. Django is used by companies like [Instagram](https://instagram-engineering.com/web-service-efficiency-at-instagram-with-python-4976d078e366), [Spotify](https://labs.spotify.com/), and also in most Penn Labs products, like [Penn Course Review](https://github.com/pennlabs/pcr)! Hopefully, understanding the Flask code presented in this lecture will help you understand how to implement and debug the functionality of your future Django apps.\n","html":"<h1>An Intro to Web Dev</h1>\n<blockquote>\n<p>Featuring the Web Framework Flask!</p>\n</blockquote>\n<p>As a programmer, it can seem like building websites involves <a href=\"https://xkcd.com/927/\">countless</a> frameworks and <a href=\"https://xkcd.com/1270/\">complex</a> paradigms… However, the <a href=\"https://www.cis.upenn.edu/~cis455/\">complexity</a> of web development has actually led to the creation of easy-to-use libraries and frameworks that abstract most of the complicated processes!</p>\n<p>In this lecture, we will be working with <a href=\"https://github.com/pallets/flask\">Flask</a>, a Python framework for web development, by using it to build a <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/REST\">REST API</a>. Web development involves a lot of moving parts - we recommend you ask many questions!</p>\n<h2>HTTP and REST APIs</h2>\n<p><strong>HTTP</strong> (Hyper Text Transfer Protocol) is a way for us to communicate between machines. The core technology was developed by Tim Berners-Lee in 1989 at CERN. Put simply, this is the underlying technology that has enabled the internet to work.</p>\n<p>HTTP is a protocol that consists solely of requests and responses. HTTP is stateless; this means that requests/responses are made independent of each other. Typically a client (e.g. website and mobile app) will make requests for resources (e.g. text/images) from a server. It’s is a common mistake to conflate <strong>HTML</strong> (Hyper Text Markup Language) with HTTP. The distinction is that HTML is the content of a webpage that will eventually be displayed to a user, where HTTP is the transportation method of the HTML.</p>\n<p>The client and server can exist as one application or separately (as is typically the case with Flask). The actual layers of the protocol can get very technical, but this is essentially all you need to understand as a Python developer. As Python developers, we build <strong>REST APIs</strong>, server applications that respond to requests accessed through urls (e.g. <a href=\"http://upenn.edu\">http://upenn.edu</a>) over HTTP. Data in REST API’s are typically sent and received using <strong>JSON</strong> (Javascript Object Notation), which follows a key-value interface similar to dictionaries.</p>\n<p>If you are interested in learning more about the infastructure of the web, we recommend checking out <a href=\"https://www.cis.upenn.edu/~mkse150/\">NETS-150</a>, <a href=\"https://www.cis.upenn.edu/~nets212/\">NETS-212</a>, or if you are feeling really adventurous, <a href=\"https://www.cis.upenn.edu/~cis455/\">CIS-455</a>!</p>\n<h2>Introducing: Flask</h2>\n<p>As mentioned above, we will be building a REST API in Python using a library named <a href=\"https://github.com/pallets/flask\">Flask</a>. Flask is a web framework that allows us to build a server that other applications can make HTTP requests to. Flask is the backbone for the architecture of a lot of Python software, including <a href=\"https://engineering.linkedin.com/blog/\">LinkedIn</a> and <a href=\"https://medium.com/pinterest-engineering/\">Pinterest</a> (but is 100% open source).</p>\n<h2>Creating a Flask application</h2>\n<p>Flask makes it quick and simple to build a server using Python. First, we need to install Flask using <code class=\"language-text\">pip</code> and create the server file. In this demo, we will be building a REST API to clone a question/answering site like Stack Overflow.</p>\n<ol>\n<li>Create a folder using <code class=\"language-text\">mkdir 192overflow</code>.</li>\n<li>Enter the folder using <code class=\"language-text\">cd 192overflow</code>.</li>\n<li>Create a file named <code class=\"language-text\">server.py</code> here with a text editor or <code class=\"language-text\">touch</code>.</li>\n<li>Install Flask using <code class=\"language-text\">pip install flask</code>.</li>\n<li>Place the following contents in the <code class=\"language-text\">server.py</code> file and save.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> flask <span class=\"token keyword\">import</span> Flask\napp <span class=\"token operator\">=</span> Flask<span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span>\n\n<span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"Hello World!\"</span>\n\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">\"__main__\"</span><span class=\"token punctuation\">:</span>\n\tapp<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>port<span class=\"token operator\">=</span><span class=\"token number\">5000</span><span class=\"token punctuation\">,</span> debug<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ol start=\"6\">\n<li>Run the server using <code class=\"language-text\">python server.py</code>.</li>\n<li>Access the server at <code class=\"language-text\">localhost:5000</code> in your web browser.</li>\n</ol>\n<h2>Defining Routes</h2>\n<p>In the above example, we build a server that exposes a REST API. Our only access point to the interface is the route <code class=\"language-text\">&quot;/”</code> that returns the return value of a function named <code class=\"language-text\">hello()</code>. We defined this behavior using the function decorator <code class=\"language-text\">@app.route(&quot;/&quot;)</code>.</p>\n<p>We can similarity create decorated functions that allow us to define more routes. Let’s change the message of our function to return <code class=\"language-text\">&quot;Welcome to 192overflow&#39;s API!&quot;</code>. The Flask server automatically reloads and if we refresh our web browser, we should see the updated value.</p>\n<h2>Making Requests to Query</h2>\n<p>We define a dictionary mapping questions to answers before we define routes:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">answers <span class=\"token operator\">=</span> <span class=\"token builtin\">dict</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># This also works!</span>\nanswers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>We can now create another route to take in an argument (a string value of the question) and return a result in JSON. We import the <code class=\"language-text\">jsonify</code> and <code class=\"language-text\">request</code> module from Flask using <code class=\"language-text\">from flask import jsonify, request</code>. We can now add another route that takes in a string of the question (using only alphanumeric characters with underscores for spaces):</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/api/answers\"</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tquestion <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>args<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'question'</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> question <span class=\"token keyword\">in</span> answers<span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> jsonify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"status\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"answer\"</span><span class=\"token punctuation\">:</span> answers<span class=\"token punctuation\">[</span>question<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> jsonify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"status\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">404</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"message\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"No answer.\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now, we can access this route from our browser supplying a URL argument for the question <code class=\"language-text\">localhost:5000/api/answers?question=what_is_love</code>. Clearly, we don’t have any questions or answers, we can change that by adding another route for adding a question and answer pairing.</p>\n<h2>Making Requests to Insert</h2>\n<p>Next, we define a route for setting the answer to a question. Both arguments are sent using a JSON encoded object, that we decode using the <code class=\"language-text\">get_json</code> function to convert the arguments to a dictionary.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/api/answers\"</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">post_answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tdata <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>get_json<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tquestion <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span><span class=\"token string\">\"question\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\tanswer <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span><span class=\"token string\">\"answer\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\tanswers<span class=\"token punctuation\">[</span>question<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> answer\n\t<span class=\"token keyword\">return</span> jsonify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"question\"</span><span class=\"token punctuation\">:</span> question<span class=\"token punctuation\">,</span> <span class=\"token string\">\"answer\"</span><span class=\"token punctuation\">:</span> answer<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We can test this in the command line using:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> --header <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  --request POST <span class=\"token punctuation\">\\</span>\n  --data <span class=\"token string\">'{\"question\":\"what_is_love\", \"answer\":\"dont_hurt_me\"}'</span> <span class=\"token punctuation\">\\</span>\n  http://localhost:5000/api/answers</code></pre></div>\n<p>If you're not on a UNIX based system (looking at you, Windows) then you can download <a href=\"https://curl.haxx.se/\">curl</a> here. Instead of the above command, navigate to the directory you unzipped the curl executable in, and run</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">curl.exe --header <span class=\"token string\">\"Content-Type: application/json\"</span> <span class=\"token punctuation\">\\</span>\n  --request POST <span class=\"token punctuation\">\\</span>\n  --data <span class=\"token string\">'{\"question\":\"what_is_love\", \"answer\":\"dont_hurt_me\"}'</span> <span class=\"token punctuation\">\\</span>\n  http://localhost:5000/api/answers</code></pre></div>\n<p>instead. (Same thing, except we're telling Windows to use the curl executable we downloaded.)</p>\n<p>Or install a graphical HTTP client like <a href=\"https://www.postman.com/\">Postman</a>, and click the 'Send' button after filling out the fields like below:\n<img src=\"https://i.imgur.com/PedEksL.png\" alt=\"screenshot\"></p>\n<h2>Exporting to JSON</h2>\n<p>However, you may have noticed that the server will wipe all the data whenever we navigate away from it. This is because our server is still a Python script and variables are often reset. We need some more persistent server-side storage, similar to how a site can remember your searches.</p>\n<p>We can use the <code class=\"language-text\">json</code> library (bundled with Python, different from <code class=\"language-text\">jsonify</code>) to save information into a <code class=\"language-text\">.json</code> file that can be serialized and deserialized as we wish. We can import the <code class=\"language-text\">json</code> library with a simple <code class=\"language-text\">import json</code>. We use the <code class=\"language-text\">with</code> keyword to safely interact with file I/O (e.g. reading and writing without worrying about closing).</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/api/answers\"</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">post_answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tdata <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>get_json<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tquestion <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span><span class=\"token string\">\"question\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\tanswer <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span><span class=\"token string\">\"answer\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">with</span> <span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'db.json'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'r'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> db_read<span class=\"token punctuation\">:</span>\n\t\tdata <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>load<span class=\"token punctuation\">(</span>db_read<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">with</span> <span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'db.json'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'w'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> db_write<span class=\"token punctuation\">:</span>\n\t\tdata<span class=\"token punctuation\">[</span>question<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> answer\n\t\tjson<span class=\"token punctuation\">.</span>dump<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> db_write<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> jsonify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"question\"</span><span class=\"token punctuation\">:</span> question<span class=\"token punctuation\">,</span> <span class=\"token string\">\"answer\"</span><span class=\"token punctuation\">:</span> answer<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We’ll also need to update how we query the database so that we query the JSON database as opposed to our <code class=\"language-text\">answers</code> dictionary.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/api/answers\"</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tquestion <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>args<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'question'</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">with</span> <span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'db.json'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'r'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> db_read<span class=\"token punctuation\">:</span>\n\t\tanswers <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>load<span class=\"token punctuation\">(</span>db_read<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> question <span class=\"token keyword\">in</span> answers<span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> jsonify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"answer\"</span><span class=\"token punctuation\">:</span> answers<span class=\"token punctuation\">[</span>question<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> jsonify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"No answer.\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>DISCLAIMER</strong>\nSaving to a local file (like our <code class=\"language-text\">db.json</code>) can create consistency issues if multiple users edit/query the same file at the same time. We’ll ignore this scenario for this course since it isn’t a Python-specific issue. There are <a href=\"https://www.seas.upenn.edu/~cis550/\">entire courses</a> devoted to solving this and the other challenges that arise when storing data, if you're interested.</p>\n<h2>Rendering HTML</h2>\n<p>Allowing others (i.e. non-technical people) to use your project will involve the use of some HTML. However, <code class=\"language-text\">.html</code> files are static, and thus aren’t good by themselves at receiving input and processing/result results. Using Flask, we can solve this by defining <strong>templates</strong> that we can “inject” Python data into. Let’s add another route to display a template at <code class=\"language-text\">GET /answers</code> (NOTE: not <code class=\"language-text\">GET /api/answers</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/answers\"</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">render_answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tquestion <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>args<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'question'</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">with</span> <span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'db.json'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'r'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> db_read<span class=\"token punctuation\">:</span>\n\t\tanswers <span class=\"token operator\">=</span> json<span class=\"token punctuation\">.</span>load<span class=\"token punctuation\">(</span>db_read<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> question <span class=\"token keyword\">in</span> answers<span class=\"token punctuation\">:</span>\n\t\t<span class=\"token comment\"># Make sure to also import render_template from flask in the imports above!</span>\n\t\t<span class=\"token keyword\">return</span> render_template<span class=\"token punctuation\">(</span><span class=\"token string\">\"answer.html\"</span><span class=\"token punctuation\">,</span> question<span class=\"token operator\">=</span>question<span class=\"token punctuation\">,</span> answer<span class=\"token operator\">=</span>answers<span class=\"token punctuation\">[</span>question<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">return</span> jsonify<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"status\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">404</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"message\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"No answer.\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Here, we perform the same logic as before in <code class=\"language-text\">/api/answers</code>. However, instead of returning a JSON response upon success, we return a rendered template. We pass in keyword arguments (i.e. <code class=\"language-text\">kwargs</code>) for the question and answer to be rendered in the HTML.</p>\n<p>Now, we need to define the HTML page. Let’s create a new folder named <code class=\"language-text\">templates</code> in the <code class=\"language-text\">192overflow</code> directory that contains a single file named <code class=\"language-text\">answer.html</code>. In this file, we’ll adding some HTML code:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Question<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>{{question}}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span>Answer<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>{{answer}}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Essentially, we are defining a webpage that has large, title text that will indicate whether the following text is a question or answer, followed by the question/answer. The double curly braces <code class=\"language-text\">{{variable}}</code> signify that some keyword argument <code class=\"language-text\">variable</code> will be passed in as a Python object to be rendered.</p>\n<h2>Conclusion</h2>\n<p>In this section of the course, you learned some crucial paradigms for web development and software engineering as a whole:</p>\n<ol>\n<li>HTTP</li>\n<li>JSON</li>\n<li>REST APIs</li>\n<li>Flask</li>\n<li>HTML rendering</li>\n</ol>\n<p>Some next steps would involve adding more routes, some way to add users, and more front-end (HTML) pages! Feel free to email the staff if you have any questions!</p>\n<p>Later assignments will be in <a href=\"https://www.djangoproject.com/\">Django</a>, another Python framework which comes with more built in functionality at the cost of being more abstract/harder to understand. Django is used by companies like <a href=\"https://instagram-engineering.com/web-service-efficiency-at-instagram-with-python-4976d078e366\">Instagram</a>, <a href=\"https://labs.spotify.com/\">Spotify</a>, and also in most Penn Labs products, like <a href=\"https://github.com/pennlabs/pcr\">Penn Course Review</a>! Hopefully, understanding the Flask code presented in this lecture will help you understand how to implement and debug the functionality of your future Django apps.</p>"}},"pageContext":{"pathSlug":"/flask"}},"staticQueryHashes":[]}