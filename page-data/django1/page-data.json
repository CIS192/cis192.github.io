{"componentChunkName":"component---src-templates-blog-post-js","path":"/django1","result":{"data":{"markdownRemark":{"rawMarkdownBody":"\n# Full Stack Development\n\n> Introduction to Django\n\nIn this lecture, we build upon last week’s topics using the Django Framework. Recall that the fundamental protocol of the internet is HTTP (Hyper Text Transfer Protocol).\n\n## About Django\n\nDjango is a web development framework that takes a “batteries included” approach. This means a lot of server configuration is done for us, while still being flexible for the developer. This is contrasted with a micro-framework like Flask, where most setup is left up to the developer to implement. A non-exhaustive list of things Django does for you:\n\n2. Built-in SQL abstraction layer (ORM) and pre-defined database connection\n3. User Authentication System\n4. Pre-Built Admin Page\n\nDjango is one of the most widely used web frameworks of all time and is used to power everything from Penn to DoorDash to NASA to Instagram. I personally love it because it alleviates a lot of headaches that can come with web development! However, since a lot of Django is pre-customized, it can be difficult at first to understand what is going on under the hood. In this lecture, we’ll draw as many comparisons to Flask as we can to elucidate the framework’s inner workings.\n\n## Initialization\n\nIn this lecture, we will be building a restaurant application that programmatically stores the menu for the restaurant and handles reservations. We install Django through pip by using `pip install django`. Then, we can create a new Django project by running `django-admin startproject restaurant`. This creates a folder named `restaurant` that we can `cd` into. We can then run `python manage.py runserver` and view a cute splash screen at `localhost:8000` (ignore the warnings about unapplied migrations).\n\n## Project Structure\n\nThe first file we notice is `manage.py`, which is used to interface with our Django project from the command line (like how we ran our server earlier). There is also an auto-generated `restaurant/` folder that contains a few default files. The `restaurant/settings.py` file contains all the pre-configured settings that Django has provided for us, which includes the database connection, the language, timezone etc. Also note that `restaurant/urls.py` contains only a single route (defined using a regular expression) corresponding to `/admin`.\n\nDjango applications are defined using a top-level project (i.e. the `restaurant` folder) and sub-projects called apps that exist within the top-level project. The structure of apps remain consistent (i.e. containing their own `urls.py` and `views.py` etc) throughout the project and allow us to modularize our code. This also helps the project scale reliably as we add more functionality and code to our project.\n\nLet’s create our first app called `about` which will serve the functionality of returning information about our restaurant by running `python manage.py startapp about`. This creates a folder named `about` in our project that contains a `urls.py` and a `views.py` already for us. Finally, in order for Django to recognize this app, we must add `about` as an installed app in the configuration. To do this, open `settings.py` and add `'about'` to the end of the list `INSTALLED_APPS`.\n\n## Creating a “Hello World“ Application\n\nGetting a page to render on Django is a multi-step process, and is a little complicated. First, like with Flask, we must consider what URL route we want our page to be displayed on. Then, we must create a _view_ function that is invoked when the route is accessed which renders some HTML file. Finally, we must create the HTML template itself. Let’s implement these in reverse order to gain a better understanding.\n\nLet’s first create a splash page for our restaurant. Create a folder named `templates` in our `about` folder. Create a file called `splash.html` in `about/templates` containing:\n\n```html\n<h1>192 Restaurant</h1>\n<p>A restaurant where the only meal is tears from Java programmers.</p>\n<p></p>\n```\n\nFeel free to open up the file in your favourite web browser to see how the page looks. Next, let’s define a _view_ in `about/views.py`. Add the following code to `view.py`:\n\n```python\ndef splash(request):\n\treturn render(request, \"splash.html\", {})\n```\n\nThe `render` function is provided by Django (and is imported by default), and takes in the request used to prompt the render (i.e. the `request` parameter in the function header), the HTML file and a dictionary of Python variables to pass through to the template. Note the similarity between this function definition and the decorated functions we wrote in the Flask framework.\n\nHowever, we haven’t linked this view to any particular route. To do this, open `restaurant/urls.py` and import the view we wrote by adding `from about.views import splash` to the top of the file. Finally, we specify the route by appending the route, view and name to the `urlpatterns` list the route specification:\n\n```python\nurlpatterns = [\n\tpath('admin/', admin.site.urls),\n\tpath('', splash, name='splash'),\n]\n```\n\nFinally, if we open our browser to `localhost:8000`, we should see our splash page!\n\n## Defining Models\n\nRight now, our application is a little basic. It would be nice if we were able to show users our restaurants menu. Assume that our menu is constantly changing. Therefore, we want to be able to use a database to store all the different meals. Let’s create a new app to handle this logic using `python manage.py startapp menu`. Before we write any functionality, we want to do is link our newly created app to our top-level restaurant project. Open `restaurant/settings.py` and add `menu` to `INSTALLED_APPS`.\n\nThe first thing we want to implement is a class that represents each meal in our menu. Django abstracts all SQL interactions so that you can just write native Python code to define all database behaviour. However, we still need to be able to tell Django that our `Meal` class should be designed for a SQL database - a strongly typed language. This will involve specifying the types of data that our object will contain. Open `menu/models.py` and add the following code:\n\n```python\nclass Meal(models.Model):\n\tname = models.CharField(max_length=200)\n\tdescription = models.TextField()\n\tvegan = models.BooleanField()\n\tprice = models.DecimalField(max_digits=6, decimal_places=2)\n```\n\nDjango comes with a variety of pre-defined model fields ranging from calendar dates to simple text fields. Here we use:\n\n1. `CharField` representing a short string (e.g. names)\n2. `TextField` representing a large text input (e.g. entire blog posts)\n3. `BooleanField` (you can figure out what data type this is)\n4. `DecimalField` (you can figure out what data type this is)\n\nNote that Django also predefines a default integer _primary key_ (or unique identifier) for all objects. We can override this if we want to prevent data redundancy by specifying `primary_key=True` in any of our model’s fields. There are a variety of other custom modifiers we can implement to squeeze more functionality into our site, but we’ll keep it basic for now!\n\nThe last thing we need to do is to migrate the database. Migrations are a powerful tool in database management to structure the database to reflect changes in model definitions. Run `python manage.py makemigrations menu` and then execute `python manage.py migrate`. The `makemigrations` command generates a specific list of changes to make to the database schema whereas the `migrate` command actually changes the database to our liking. This is increasingly important when our database is in production since we want changes to our database to be done in a way that doesn’t lose any existing information.\n\n## Admin Management\n\nSo, we’ve defined a custom class for the meals that our restaurant serves. However, we don’t really have any ways to instantiate instances of our class yet. Let’s fix that by using the robust Django Admin page. If we look at our `urlpatterns` in `restaurant/urls.py`, we can see a route at `/admin`. Run the server again and pay a visit to `localhost:8000/admin`. Notice it asks for a username and password - which we don’t have yet. Let’s make ourselves admins of our restaurant site by quitting the server (CTRL-C) and running `python manage.py createsuperuser` to enter a username and password for our admin account.\n\nOur admin account is able to manipulate the database however we choose. At first glance, this doesn’t seem too important - can’t we just edit the database directly? Well, first, directly altering our database is 99% of the time a bad idea and second, writing raw SQL isn’t always the most intuitive way to change the database (think if we wanted to pass this application over to the restaurant’s non-technical owner).\n\nOpen up the admin page again and log in with your newly created admin account credentials. We’re greeted with a very blank looking portal that doesn’t even have our `Meal` class listed - we have to link the class ourself. This is actually by design, since a lot of Django’s SQL tables are autogenerated and thus don’t need to clutter our nice admin page. In `menu/admin.py` import the class at the top using `from menu.models import Meal` and add `admin.site.register(Meal)`. Go back to the admin page and we should be able to add new meals to the menu! Add some vegan meals and some non-vegan meals.\n\nTwo things to appreciate here:\n\n1. Django already comes with a secure implementation of an accounts system.\n2. Django’s admin page comes pre-built (and is surprisingly easy to use).\n\n## Querying Model\n\nWe are almost done with the base of our restaurant website! The last thing we want to do is a way to retrieve the meals in our database and query by specific fields. In our `menu/view.py` file create a new view function called `meals` that renders a template named `meals.html` (create this view and template based off of the earlier “Hello World” section). Link this view to the route `/meals` in `restaurant/urls.py`. This should render a static page at `/meals`. You may notice that if you declare the route as `path('meals', meals, name='meals')` instead of `\tpath('meals/', meals, name='meals')`, navigating to `/meals` will result in a 404 error. This is because Django automatically appends a `/` to requests in order normalize URLs. You can read about this decision [here](https://docs.djangoproject.com/en/3.0/misc/design-philosophies/#definitive-urls).\n\nWe now want a way to programmatically retrieve all the meals and pass them through to the template to render them. We first import the meal class in `menu/views.py` using `from menu.models import Meal`. In our view function, before we call `render`, retrieve all the instances of this class using `meals = Meal.objects.all()`. If we print out `meals`, we should see a `QuerySet` of objects. This is just a fancy way for Django to serialize all of our objects in a Django-compatible way. We can simply iterate over this in Python using `for meal in meals` and printing their names using `print(meal.name)`. Finally, let’s pass this through to the template by adding it into the dictionary in the request call: `return render(request, \"meals.html\", {\"meals\": meals})`.\n\nFinally, we can iterate over these objects in our template using a similar syntax as in Flask:\n\n```html\n{% for meal in meals %}\n<p>{{meal.name}}: {{meal.description}}</p>\n<p>Vegan: {{meal.vegan}}</p>\n{% endfor %}\n```\n\n## Conclusion\n\nIn this lecture, we developed an application that uses a SQL database to store meals for a restaurant. These notions are the fundamentals behind any large scale web service from Dropbox to Facebook. In particular, Django does a lot of heavy lifting for us so we don’t need to implement certain complicated aspects of web development like SQL interactions and user accounts. In the next lecture, we will cover (non-admin) user accounts, more complex database querying and cloud deployment. As further reference, we strongly recommend taking a look at the excellent [Django documentation](https://docs.djangoproject.com/en/3.0/) if you'd like to learn more.\n\n## Exercises\n\nImplement HW1 in Django using MySQL as a database (instead of the file system). This should take roughly 1 - 2 hours and will be good practice for HW2.\n\n---\n\n### References\n\n1. [URL Design - Django Documentation](https://docs.djangoproject.com/en/3.0/misc/design-philosophies/#definitive-urls)\n2. [Django Documentation](https://docs.djangoproject.com/en/3.0/)\n","html":"<h1>Full Stack Development</h1>\n<blockquote>\n<p>Introduction to Django</p>\n</blockquote>\n<p>In this lecture, we build upon last week’s topics using the Django Framework. Recall that the fundamental protocol of the internet is HTTP (Hyper Text Transfer Protocol).</p>\n<h2>About Django</h2>\n<p>Django is a web development framework that takes a “batteries included” approach. This means a lot of server configuration is done for us, while still being flexible for the developer. This is contrasted with a micro-framework like Flask, where most setup is left up to the developer to implement. A non-exhaustive list of things Django does for you:</p>\n<ol start=\"2\">\n<li>Built-in SQL abstraction layer (ORM) and pre-defined database connection</li>\n<li>User Authentication System</li>\n<li>Pre-Built Admin Page</li>\n</ol>\n<p>Django is one of the most widely used web frameworks of all time and is used to power everything from Penn to DoorDash to NASA to Instagram. I personally love it because it alleviates a lot of headaches that can come with web development! However, since a lot of Django is pre-customized, it can be difficult at first to understand what is going on under the hood. In this lecture, we’ll draw as many comparisons to Flask as we can to elucidate the framework’s inner workings.</p>\n<h2>Initialization</h2>\n<p>In this lecture, we will be building a restaurant application that programmatically stores the menu for the restaurant and handles reservations. We install Django through pip by using <code class=\"language-text\">pip install django</code>. Then, we can create a new Django project by running <code class=\"language-text\">django-admin startproject restaurant</code>. This creates a folder named <code class=\"language-text\">restaurant</code> that we can <code class=\"language-text\">cd</code> into. We can then run <code class=\"language-text\">python manage.py runserver</code> and view a cute splash screen at <code class=\"language-text\">localhost:8000</code> (ignore the warnings about unapplied migrations).</p>\n<h2>Project Structure</h2>\n<p>The first file we notice is <code class=\"language-text\">manage.py</code>, which is used to interface with our Django project from the command line (like how we ran our server earlier). There is also an auto-generated <code class=\"language-text\">restaurant/</code> folder that contains a few default files. The <code class=\"language-text\">restaurant/settings.py</code> file contains all the pre-configured settings that Django has provided for us, which includes the database connection, the language, timezone etc. Also note that <code class=\"language-text\">restaurant/urls.py</code> contains only a single route (defined using a regular expression) corresponding to <code class=\"language-text\">/admin</code>.</p>\n<p>Django applications are defined using a top-level project (i.e. the <code class=\"language-text\">restaurant</code> folder) and sub-projects called apps that exist within the top-level project. The structure of apps remain consistent (i.e. containing their own <code class=\"language-text\">urls.py</code> and <code class=\"language-text\">views.py</code> etc) throughout the project and allow us to modularize our code. This also helps the project scale reliably as we add more functionality and code to our project.</p>\n<p>Let’s create our first app called <code class=\"language-text\">about</code> which will serve the functionality of returning information about our restaurant by running <code class=\"language-text\">python manage.py startapp about</code>. This creates a folder named <code class=\"language-text\">about</code> in our project that contains a <code class=\"language-text\">urls.py</code> and a <code class=\"language-text\">views.py</code> already for us. Finally, in order for Django to recognize this app, we must add <code class=\"language-text\">about</code> as an installed app in the configuration. To do this, open <code class=\"language-text\">settings.py</code> and add <code class=\"language-text\">&#39;about&#39;</code> to the end of the list <code class=\"language-text\">INSTALLED_APPS</code>.</p>\n<h2>Creating a “Hello World“ Application</h2>\n<p>Getting a page to render on Django is a multi-step process, and is a little complicated. First, like with Flask, we must consider what URL route we want our page to be displayed on. Then, we must create a <em>view</em> function that is invoked when the route is accessed which renders some HTML file. Finally, we must create the HTML template itself. Let’s implement these in reverse order to gain a better understanding.</p>\n<p>Let’s first create a splash page for our restaurant. Create a folder named <code class=\"language-text\">templates</code> in our <code class=\"language-text\">about</code> folder. Create a file called <code class=\"language-text\">splash.html</code> in <code class=\"language-text\">about/templates</code> containing:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>192 Restaurant<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>A restaurant where the only meal is tears from Java programmers.<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>Feel free to open up the file in your favourite web browser to see how the page looks. Next, let’s define a <em>view</em> in <code class=\"language-text\">about/views.py</code>. Add the following code to <code class=\"language-text\">view.py</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">splash</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">return</span> render<span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> <span class=\"token string\">\"splash.html\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The <code class=\"language-text\">render</code> function is provided by Django (and is imported by default), and takes in the request used to prompt the render (i.e. the <code class=\"language-text\">request</code> parameter in the function header), the HTML file and a dictionary of Python variables to pass through to the template. Note the similarity between this function definition and the decorated functions we wrote in the Flask framework.</p>\n<p>However, we haven’t linked this view to any particular route. To do this, open <code class=\"language-text\">restaurant/urls.py</code> and import the view we wrote by adding <code class=\"language-text\">from about.views import splash</code> to the top of the file. Finally, we specify the route by appending the route, view and name to the <code class=\"language-text\">urlpatterns</code> list the route specification:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">urlpatterns <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n\tpath<span class=\"token punctuation\">(</span><span class=\"token string\">'admin/'</span><span class=\"token punctuation\">,</span> admin<span class=\"token punctuation\">.</span>site<span class=\"token punctuation\">.</span>urls<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\tpath<span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> splash<span class=\"token punctuation\">,</span> name<span class=\"token operator\">=</span><span class=\"token string\">'splash'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Finally, if we open our browser to <code class=\"language-text\">localhost:8000</code>, we should see our splash page!</p>\n<h2>Defining Models</h2>\n<p>Right now, our application is a little basic. It would be nice if we were able to show users our restaurants menu. Assume that our menu is constantly changing. Therefore, we want to be able to use a database to store all the different meals. Let’s create a new app to handle this logic using <code class=\"language-text\">python manage.py startapp menu</code>. Before we write any functionality, we want to do is link our newly created app to our top-level restaurant project. Open <code class=\"language-text\">restaurant/settings.py</code> and add <code class=\"language-text\">menu</code> to <code class=\"language-text\">INSTALLED_APPS</code>.</p>\n<p>The first thing we want to implement is a class that represents each meal in our menu. Django abstracts all SQL interactions so that you can just write native Python code to define all database behaviour. However, we still need to be able to tell Django that our <code class=\"language-text\">Meal</code> class should be designed for a SQL database - a strongly typed language. This will involve specifying the types of data that our object will contain. Open <code class=\"language-text\">menu/models.py</code> and add the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Meal</span><span class=\"token punctuation\">(</span>models<span class=\"token punctuation\">.</span>Model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tname <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>CharField<span class=\"token punctuation\">(</span>max_length<span class=\"token operator\">=</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span>\n\tdescription <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>TextField<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tvegan <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>BooleanField<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tprice <span class=\"token operator\">=</span> models<span class=\"token punctuation\">.</span>DecimalField<span class=\"token punctuation\">(</span>max_digits<span class=\"token operator\">=</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> decimal_places<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Django comes with a variety of pre-defined model fields ranging from calendar dates to simple text fields. Here we use:</p>\n<ol>\n<li><code class=\"language-text\">CharField</code> representing a short string (e.g. names)</li>\n<li><code class=\"language-text\">TextField</code> representing a large text input (e.g. entire blog posts)</li>\n<li><code class=\"language-text\">BooleanField</code> (you can figure out what data type this is)</li>\n<li><code class=\"language-text\">DecimalField</code> (you can figure out what data type this is)</li>\n</ol>\n<p>Note that Django also predefines a default integer <em>primary key</em> (or unique identifier) for all objects. We can override this if we want to prevent data redundancy by specifying <code class=\"language-text\">primary_key=True</code> in any of our model’s fields. There are a variety of other custom modifiers we can implement to squeeze more functionality into our site, but we’ll keep it basic for now!</p>\n<p>The last thing we need to do is to migrate the database. Migrations are a powerful tool in database management to structure the database to reflect changes in model definitions. Run <code class=\"language-text\">python manage.py makemigrations menu</code> and then execute <code class=\"language-text\">python manage.py migrate</code>. The <code class=\"language-text\">makemigrations</code> command generates a specific list of changes to make to the database schema whereas the <code class=\"language-text\">migrate</code> command actually changes the database to our liking. This is increasingly important when our database is in production since we want changes to our database to be done in a way that doesn’t lose any existing information.</p>\n<h2>Admin Management</h2>\n<p>So, we’ve defined a custom class for the meals that our restaurant serves. However, we don’t really have any ways to instantiate instances of our class yet. Let’s fix that by using the robust Django Admin page. If we look at our <code class=\"language-text\">urlpatterns</code> in <code class=\"language-text\">restaurant/urls.py</code>, we can see a route at <code class=\"language-text\">/admin</code>. Run the server again and pay a visit to <code class=\"language-text\">localhost:8000/admin</code>. Notice it asks for a username and password - which we don’t have yet. Let’s make ourselves admins of our restaurant site by quitting the server (CTRL-C) and running <code class=\"language-text\">python manage.py createsuperuser</code> to enter a username and password for our admin account.</p>\n<p>Our admin account is able to manipulate the database however we choose. At first glance, this doesn’t seem too important - can’t we just edit the database directly? Well, first, directly altering our database is 99% of the time a bad idea and second, writing raw SQL isn’t always the most intuitive way to change the database (think if we wanted to pass this application over to the restaurant’s non-technical owner).</p>\n<p>Open up the admin page again and log in with your newly created admin account credentials. We’re greeted with a very blank looking portal that doesn’t even have our <code class=\"language-text\">Meal</code> class listed - we have to link the class ourself. This is actually by design, since a lot of Django’s SQL tables are autogenerated and thus don’t need to clutter our nice admin page. In <code class=\"language-text\">menu/admin.py</code> import the class at the top using <code class=\"language-text\">from menu.models import Meal</code> and add <code class=\"language-text\">admin.site.register(Meal)</code>. Go back to the admin page and we should be able to add new meals to the menu! Add some vegan meals and some non-vegan meals.</p>\n<p>Two things to appreciate here:</p>\n<ol>\n<li>Django already comes with a secure implementation of an accounts system.</li>\n<li>Django’s admin page comes pre-built (and is surprisingly easy to use).</li>\n</ol>\n<h2>Querying Model</h2>\n<p>We are almost done with the base of our restaurant website! The last thing we want to do is a way to retrieve the meals in our database and query by specific fields. In our <code class=\"language-text\">menu/view.py</code> file create a new view function called <code class=\"language-text\">meals</code> that renders a template named <code class=\"language-text\">meals.html</code> (create this view and template based off of the earlier “Hello World” section). Link this view to the route <code class=\"language-text\">/meals</code> in <code class=\"language-text\">restaurant/urls.py</code>. This should render a static page at <code class=\"language-text\">/meals</code>. You may notice that if you declare the route as <code class=\"language-text\">path(&#39;meals&#39;, meals, name=&#39;meals&#39;)</code> instead of <code class=\"language-text\">path(&#39;meals/&#39;, meals, name=&#39;meals&#39;)</code>, navigating to <code class=\"language-text\">/meals</code> will result in a 404 error. This is because Django automatically appends a <code class=\"language-text\">/</code> to requests in order normalize URLs. You can read about this decision <a href=\"https://docs.djangoproject.com/en/3.0/misc/design-philosophies/#definitive-urls\">here</a>.</p>\n<p>We now want a way to programmatically retrieve all the meals and pass them through to the template to render them. We first import the meal class in <code class=\"language-text\">menu/views.py</code> using <code class=\"language-text\">from menu.models import Meal</code>. In our view function, before we call <code class=\"language-text\">render</code>, retrieve all the instances of this class using <code class=\"language-text\">meals = Meal.objects.all()</code>. If we print out <code class=\"language-text\">meals</code>, we should see a <code class=\"language-text\">QuerySet</code> of objects. This is just a fancy way for Django to serialize all of our objects in a Django-compatible way. We can simply iterate over this in Python using <code class=\"language-text\">for meal in meals</code> and printing their names using <code class=\"language-text\">print(meal.name)</code>. Finally, let’s pass this through to the template by adding it into the dictionary in the request call: <code class=\"language-text\">return render(request, &quot;meals.html&quot;, {&quot;meals&quot;: meals})</code>.</p>\n<p>Finally, we can iterate over these objects in our template using a similar syntax as in Flask:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">{% for meal in meals %}\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>{{meal.name}}: {{meal.description}}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Vegan: {{meal.vegan}}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n{% endfor %}</code></pre></div>\n<h2>Conclusion</h2>\n<p>In this lecture, we developed an application that uses a SQL database to store meals for a restaurant. These notions are the fundamentals behind any large scale web service from Dropbox to Facebook. In particular, Django does a lot of heavy lifting for us so we don’t need to implement certain complicated aspects of web development like SQL interactions and user accounts. In the next lecture, we will cover (non-admin) user accounts, more complex database querying and cloud deployment. As further reference, we strongly recommend taking a look at the excellent <a href=\"https://docs.djangoproject.com/en/3.0/\">Django documentation</a> if you'd like to learn more.</p>\n<h2>Exercises</h2>\n<p>Implement HW1 in Django using MySQL as a database (instead of the file system). This should take roughly 1 - 2 hours and will be good practice for HW2.</p>\n<hr>\n<h3>References</h3>\n<ol>\n<li><a href=\"https://docs.djangoproject.com/en/3.0/misc/design-philosophies/#definitive-urls\">URL Design - Django Documentation</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/3.0/\">Django Documentation</a></li>\n</ol>"}},"pageContext":{"pathSlug":"/django1"}},"staticQueryHashes":[]}